/*
 * generated by Xtext 2.11.0
 */
package it.unige.csec.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.naming.IQualifiedNameProvider

import com.google.inject.Inject

import it.unige.csec.lmet.*
import java.util.Map
import org.eclipse.emf.common.util.EList
import it.unige.csec.lmet.ActionDef
import java.util.HashMap
import it.unige.csec.lmet.impl.*
import it.unige.csec.lmet.Action
import it.unige.csec.lmet.SemiringDef
import java.util.Vector

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LmetGenerator extends AbstractGenerator {
	
	var preamble = ""
	// "(set-option :produce-models true)\n(set-logic QF_LIA)\n"
	var conclusion = "(check-sat)\n(get-model)\n"
	
	var cnt = 0
	var tmp = "t"
	var vsize = 0
	var times = "*"
	var plus = "+"
	
	@Inject extension IQualifiedNameProvider
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for(e: resource.allContents.toIterable.filter(Program)) {
	      	fsa.generateFile(resource.URI.lastSegment.replace(".lmet", ".smt"), e.compile)
	    }
	}
	
	def fresh() {
		cnt++
		tmp+cnt
	}
	
	def compile(Program p) {
		var semirings = make_semirings(p.semirings)
		vsize = semirings.size
		var tab = make_table(p.table)
		var root = "out"
		preamble + "(declare-fun "+root+" (Int) Int)\n" + compile(p.term, tab, root) + conclusion
	}
	
	def make_semirings(EList<SemiringDef> list) {
		var semi = new Vector<Semiring>()
		for(sd : list) {
			semi.add(sd.semi)
		}
		semi
	}
	
	def vector_size(EList<ActionDef> list) {
		list.get(0).vect.size
	}
	
	def make_table(EList<ActionDef> list) {
		var map = new HashMap<Action,EList<Integer>>()
		for(ActionDef ad : list) {
			if(ad.vect.size != vsize)
				throw new UnsupportedOperationException("Wrong number of elements")
			map.put(ad.act, ad.vect)
		}
		map 
	}
	
	def compile(Term t, Map<Action, EList<Integer>> tab, String v) {
		switch t {
			Action : compile(t as Action, tab, v)
			Variable : compile(t as Variable, tab, v)
			Sequence : compile(t as Sequence, tab, v)
			Choice : compile(t as Choice, tab, v)
			Parallel : compile(t as Parallel, tab, v)
			Recursion : compile(t as Recursion, tab, v)
			SecFrame : compile(t as SecFrame, tab, v)
			MetFrame : compile(t as MetFrame, tab, v)
    		default : ""
  		}
  	}
  	
  	def compile(Action a, Map<Action,EList<Integer>> tab, String v) {
  		var s = ""
  		for(var i = 0 ; i < vsize ; i++) {
  			s += "(assert (= (" + v +" "+ i +") "+ get(tab,a,i) +"))\n"
  		}
  		s
  	}
	
	def get(Map<Action, EList<Integer>> map, Action action, int i) {
		for(a : map.keySet) {
			if(a.act.equals(action.act) && a.res.equals(action.res))
				return map.get(a).get(i)
		}
		throw new UnsupportedOperationException("Unknown action "+action);
	}
	
  	def compile(Variable x, Map<Action,EList<Integer>> tab, String v) {
  		'''(assert VARIABLE)'''
  	}
  	
  	def compile(Sequence a, Map<Action,EList<Integer>> tab, String v) {
  		var fst = fresh()
  		var snd = fresh()
  		var s = "(declare-fun "+fst+" (Int) Int)\n(declare-fun "+snd+" (Int) Int)\n"
  		s += compile(a.left, tab, fst)
  		s += compile(a.right, tab, snd)
  		for(var i = 0 ; i < vsize ; i++) {
  			s += "(assert (= ("+ v +" "+ i +") ("+ times +" ("+ fst + " " + i + ") ("+ snd + " " + i + "))))\n"
  		}
  		s
		
  	}
  	
  	def compile(Choice a, Map<Action,EList<Integer>> tab, String v) {
  		var fst = fresh()
  		var snd = fresh()
  		var s = "(declare-fun "+fst+" (Int) Int)\n(declare-fun "+snd+" (Int) Int)\n"
  		s += compile(a.left, tab, fst)
  		s += compile(a.right, tab, snd)
  		for(var i = 0 ; i < vsize ; i++) {
  			s += "(assert (= ("+ v +" "+ i +") ("+ plus +" ("+ fst + " " + i + ") ("+ snd + " " + i + "))))\n"
  		}
  		s
  	}
  	
  	def compile(Parallel a, Map<Action,EList<Integer>> tab, String v) {
  		var fst = fresh()
  		var snd = fresh()
  		var s = "(declare-fun "+fst+" (Int) Int)\n(declare-fun "+snd+" (Int) Int)\n"
  		s += compile(a.left, tab, fst)
  		s += compile(a.right, tab, snd)
  		for(var i = 0 ; i < vsize ; i++) {
  			s += "(assert (= ("+ v +" "+ i +") ("+ times +" ("+ fst + " " + i + ") ("+ snd + " " + i + "))))\n"
  		}
  		s
  	}
  	
  	def compile(Recursion a, Map<Action,EList<Integer>> tab, String v) {
  		'''(assert RECURSION)'''
  	}
  	
  	def compile(SecFrame a, Map<Action,EList<Integer>> tab, String v) {
  		compile(a.sub,tab,v)
  	}
  	
  	def compile(MetFrame a, Map<Action,EList<Integer>> tab, String v) {
  		var s = ""
  		s += compile(a.sub,tab,v)
  		for(var i = 0 ; i < vsize ; i++) {
  			s += "(assert ("+ a.const.rel +" ("+ v +" "+ i +") "+ a.const.vals.get(i) +"))\n"
  		}
  		s
  	}
}
